#!/usr/bin/perl
#
# <cmpResPock.pl>
#

$LastModDate = "Jan 14, 2009";

$OPT{'ores'} = 'ORES';
$OPT{'olig'} = 'LIG';
$OPT{'wbin'} = 1;
$OPT{'we'}   = 0.5;
$OPT{'wm'}   = 0.1;
$OPT{'lpat'} = '.';
$OPT{'ohp'} = 'pock.hist';
$OPT{'ohpb'} = 'pockb.hist';
$OPT{'ohpa'} = 'pocka.hist';
$OPT{'oinf'} = '';

if (scalar(@ARGV)<1)
{
 print "cmpResPock.pl [listfile] <options>\n";
 printf(" compare residue-based pocketness with various other residue-based properties.\n");
 printf(" coded by T.Kawabata. LastModified:%s\n",$LastModDate);
 printf("-ores  : Input Dir. of residue-based pocketness file [%s]\n",$OPT{'ores'});
 printf("-olig  : Input Dir. of ligand-contact residue file generated by 'Ligand' [%s]\n",$OPT{'olig'});
 printf("-oacc  : Input Dir. of LeeRich ACC file [%s]\n",$OPT{'oacc'});
 printf("-oinf  : Input Dir. of PDBINF file [%s]\n",$OPT{'oinf'});
 printf("-oprf  : Input Dir. of PsiBlast file [%s]\n",$OPT{'oprf'});
 printf("-ovsq  : Input Dir. of Vertical Sequence file [%s]\n",$OPT{'ovsq'});
 printf("-of    : Dir. of Output  [%s]\n",$OPT{'of'});
 printf("-wbin  : Width of bin of Pocketness histogram  [%s]\n",$OPT{'wbin'});
 printf("-we    : Width of bin of entropy  [%s]\n",$OPT{'we'});
 printf("-wm    : Width of bin of max_freq  [%s]\n",$OPT{'wm'});
 printf("-lpat  : Three letter pattern for ligand  [%s]\n",$OPT{'lpat'});
 printf("-nlpat : Three letter not-match pattern for ligand  [%s]\n",$OPT{'nlpat'});
 printf("-ohp   : Out histofile for pocketness  [%s]\n",$OPT{'ohp'});
 printf("-ohpb  : Out histo file for pocketness for binding site [%s]\n",$OPT{'ohpb'});
 printf("-ohpa  : Out histo file for pocketness for active site [%s]\n",$OPT{'ohpa'});
 printf("-ohs   : Out histo file for shellAcc  [%s]\n",$OPT{'ohs'});
 printf("-ohsb  : Out histo file for shellAcc for binding site [%s]\n",$OPT{'ohsb'});
 printf("-ohsa  : Out histo file for shellAcc for active site [%s]\n",$OPT{'ohsa'});
 printf("-oha   : Out histo file for RACC  [%s]\n",$OPT{'oha'});
 printf("-ohab  : Out histo file for RACC for binding site [%s]\n",$OPT{'ohab'});
 printf("-ohaa  : Out histo file for RACC for binding site [%s]\n",$OPT{'ohaa'});
 printf("-ohe   : Out histo file for ENTROPY [%s]\n",$OPT{'ohe'});
 printf("-oheb  : Out histo file for ENTROPY for binding site [%s]\n",$OPT{'oheb'});
 printf("-ohea  : Out histo file for ENTROPY for active site [%s]\n",$OPT{'ohea'});
 printf("-ohm   : Out histo file for MAX_FREQ [%s]\n",$OPT{'ohe'});
 printf("-ohma  : Out histo file for MAX_FREQ for active site [%s]\n",$OPT{'ohea'});
 printf("-oall  : Out All the residue-based values into one file [%s]\n",$OPT{'oall'});
 exit(1);
}

$ilistfile = $ARGV[0];
&Read_Options(\@ARGV,\%OPT);

## [1] Read list file ##
&Read_List_File($ilistfile,\@LIST);
$Npro = scalar(@LIST);
$Naa_all = $Naabind_all = 0; $Npro_bind = 0;
if ($OPT{'oall'} ne '') { 
 printf("#Output_All_Residue-based_Values --> '%s'\n",$OPT{'oall'});
 open(OF,">$OPT{'oall'}")||die "#Error:Can't write to 'oall'";
 printf(OF "#ALL_RESIDUE_BASED_PROPERTIES\n");
 printf(OF "#COMMAND %s\n",$OPT{'COMMAND'});
 printf(OF "#DATE    %s\n",&Get_Date_String());
 close(OF);
}

## [2] for loop for each protein in the list @LIST ##


foreach $p (@LIST){
 $chain = substr($p,4,1);
 $pockfile = $OPT{'ores'}.'/'.$p;
 %PockDat = ();
 &Read_Residue_based_Pocketness_File($pockfile,\%PockDat);
 &Count_Histogram(\%PockDat,$OPT{'wbin'},\%Npocketness,'pocketness');
 &Count_Histogram(\%PockDat,$OPT{'wbin'},\%NshellAcc,'shellAcc');

 if ($OPT{'oacc'} ne ''){
  $accfile = $OPT{'oacc'}.'/'.$p;
  &Read_Residue_based_LeeRich_ACC_File($accfile,\%PockDat);
  &Count_Histogram(\%PockDat,$OPT{'wbin'},\%NRACC,'RACC');
 }
 

 if ($OPT{'ovsq'} ne ''){
  $ifile = $OPT{'ovsq'}.'/'.$p;
  &Read_Vertical_PDB_Num_Sequence_File($ifile,\%PockDat); 
 }
 
  if ($OPT{'oprf'} ne ''){
  $ifile = $OPT{'oprf'}.'/'.$p;
  &Read_PsiBlast_Profile_File($ifile,\%PockDat); 
  &Count_Histogram(\%PockDat,$OPT{'we'},\%Nentropy,'ENTROPY');
  &Count_Histogram(\%PockDat,$OPT{'wm'},\%Nmaxfreq,'MAXFREQ');
  }

 if ($OPT{'oinf'} ne ''){
  $inffile = $OPT{'oinf'}.'/'.$p;
  &Read_PDBINF_File($inffile,\%PockDat);
  &Count_Histogram_Only_For_ACT_SITE_Residue(\%PockDat,$OPT{'wbin'},\%Npocketness_act,'pocketness');
  &Count_Histogram_Only_For_ACT_SITE_Residue(\%PockDat,$OPT{'wbin'},\%NshellAcc_act,'shellAcc');
  &Count_Histogram_Only_For_ACT_SITE_Residue(\%PockDat,$OPT{'wbin'},\%NRACC_act,'RACC');
  &Count_Histogram_Only_For_ACT_SITE_Residue(\%PockDat,$OPT{'we'},\%Nentropy_act,'ENTROPY');
  &Count_Histogram_Only_For_ACT_SITE_Residue(\%PockDat,$OPT{'wm'},\%Nmaxfreq_act,'MAXFREQ');
  &Count_Histogram_Only_For_MOD_RES_Residue(\%PockDat,$OPT{'wbin'},\%Npocketness_mod,'pocketness');
  &Count_Histogram_Only_For_MOD_RES_Residue(\%PockDat,$OPT{'wbin'},\%NshellAcc_mod,'shellAcc');
  &Count_Histogram_Only_For_MOD_RES_Residue(\%PockDat,$OPT{'wbin'},\%NRACC_mod,'RACC');
 }

 


 if ($OPT{'olig'} ne ''){ 
  $ligfile = $OPT{'olig'}.'/'.$p;
  print "ligfile $ligfile\n";
  &Read_Residue_based_Ligand_File($ligfile,\%Lig);
  if ($OPT{'lpat'} ne ''){
   $Naabind = &Mark_Binding_Residue(\%PockDat,\%Lig,$OPT{'lpat'},\@LigList);
  }
  if ($OPT{'nlpat'} ne ''){
   $Naabind = &Mark_Binding_Residue_Not_Match_Pattern(\%PockDat,\%Lig,$OPT{'nlpat'},\@LigList);
  }
  $ligstr = '';
  foreach $lig (@LigList) {$ligstr .= "$lig ";}
  &Count_Histogram_Only_For_Binding_Residue(\%PockDat,$OPT{'wbin'},\%Npocketness_bind,'pocketness');
  &Count_Histogram_Only_For_Binding_Residue(\%PockDat,$OPT{'wbin'},\%NshellAcc_bind,'shellAcc');
  &Count_Histogram_Only_For_Binding_Residue(\%PockDat,$OPT{'wbin'},\%NRACC_bind,'RACC');
  &Count_Histogram_Only_For_Binding_Residue(\%PockDat,$OPT{'we'},\%Nentropy_bind,'ENTROPY');
  &Count_Histogram_Only_For_Binding_Residue(\%PockDat,$OPT{'wm'},\%Nmaxfreq_bind,'MAXFREQ');
 } 
 @reslist = keys(%PockDat);
 $Naa = scalar(@reslist);
 if ($Naabind>0) {
  printf("protein $p Naa %d Naabind %d LIG $ligstr\n",$Naa,$Naabind);
  push(@COMMENT,"#$p Naa $Naa Naabind $Naabind LIG $ligstr");
  $Npro_bind += 1;
 }
 $Naa_all      += $Naa;
 $Naabind_all  += $Naabind;
 if ($OPT{'oall'} ne '') { &Write_Residue_Based_Data($OPT{'oall'},'a',\%PockDat,$p); }
}


### [3] Output results ####


push(@COMMENT,"Npro $Npro    Npro_bind $Npro_bind");
push(@COMMENT,"Naa  $Naa_all Naabind_all $Naabind_all");

if ($OPT{'ohp'} ne '')  {&Write_Histogram($OPT{'ohp'},\%Npocketness,\%Npocketness,\@COMMENT);}
if ($OPT{'ohpb'} ne '') {&Write_Histogram($OPT{'ohpb'},\%Npocketness_bind,\%Npocketness,\@COMMENT);}
if ($OPT{'ohpa'} ne '') {&Write_Histogram($OPT{'ohpa'},\%Npocketness_act,\%Npocketness,\@COMMENT);}
if ($OPT{'ohpm'} ne '') {&Write_Histogram($OPT{'ohpm'},\%Npocketness_mod,\%Npocketness,\@COMMENT);}

if ($OPT{'ohs'} ne '')  {&Write_Histogram($OPT{'ohs'},\%NshellAcc,\%NshellAcc,\@COMMENT);}
if ($OPT{'ohsb'} ne '') {&Write_Histogram($OPT{'ohsb'},\%NshellAcc_bind,\%NshellAcc,\@COMMENT);}
if ($OPT{'ohsa'} ne '') {&Write_Histogram($OPT{'ohsa'},\%NshellAcc_act,\%NshellAcc,\@COMMENT);}
if ($OPT{'ohsm'} ne '') {&Write_Histogram($OPT{'ohsm'},\%NshellAcc_mod,\%NshellAcc,\@COMMENT);}

if ($OPT{'oha'} ne '')  {&Write_Histogram($OPT{'oha'},\%NRACC,\%NRACC,\@COMMENT);}
if ($OPT{'ohab'} ne '') {&Write_Histogram($OPT{'ohab'},\%NRACC_bind,\%NRACC,\@COMMENT);}
if ($OPT{'ohaa'} ne '') {&Write_Histogram($OPT{'ohaa'},\%NRACC_act,\%NRACC,\@COMMENT);}
if ($OPT{'oham'} ne '') {&Write_Histogram($OPT{'oham'},\%NRACC_mod,\%NRACC,\@COMMENT);}

if ($OPT{'ohe'} ne '')  {&Write_Histogram($OPT{'ohe'},\%Nentropy,\%Nentropy,\@COMMENT);}
if ($OPT{'oheb'} ne '')  {&Write_Histogram($OPT{'oheb'},\%Nentropy_bind,\%Nentropy,\@COMMENT);}
if ($OPT{'ohea'} ne '')  {&Write_Histogram($OPT{'ohea'},\%Nentropy_act,\%Nentropy,\@COMMENT);}

if ($OPT{'ohm'} ne '')  {&Write_Histogram($OPT{'ohm'},\%Nmaxfreq,\%Nmaxfreq,\@COMMENT);}
if ($OPT{'ohmb'} ne '')  {&Write_Histogram($OPT{'ohmb'},\%Nmaxfreq_bind,\%Nmaxfreq,\@COMMENT);}
if ($OPT{'ohma'} ne '')  {&Write_Histogram($OPT{'ohma'},\%Nmaxfreq_act,\%Nmaxfreq,\@COMMENT);}

#################
### FUNCTIONS ###
#################


sub Write_Residue_Based_Data{
 my($ofname,$mode, $pdat,$pdbname) = @_;
 my($OF); my(@reslist);
 if ($mode eq 'a') { open(OF,">>$ofname")||die "#ERROR:Can't write to ofname '$ofname'"; }

 printf(OF "#PDBNAME $pdbname\n");
 printf(OF "#[RNUM(1)] [CHAIN(2)] [RES(3)] [pdbname(4)] [shellAcc(5)] [pocketness(6)] [RACC(7)] [AAFREQ(8)] [AAINF(9)] [AAENT(10)]\n");
 printf(OF "#[BIND] [ACT_SITE]\n");
 
 @reslist = sort {$a <=> $b} keys(%{$pdat});

 foreach $res (@reslist){
  printf(OF "%s %s %s %s %s %.1f %d %.2f %.2f",
  $res,$pdat->{$res}->{'RES'},$pdbname,
  $pdat->{$res}->{'shellAcc'},$pdat->{$res}->{'pocketness'},
   $pdat->{$res}->{'RACC'},$pdat->{$res}->{'FREQ'},
   $pdat->{$res}->{'INFO'},$pdat->{$res}->{'ENTROPY'});
  if ($pdat->{$res}->{'BIND'} == 1) {printf(OF " BIND");}
  if ($pdat->{$res}->{'ACT_SITE'} == 1) {printf(OF " ACT_SITE");}
  printf(OF "\n"); 
}
 close(OF);
} ## end of Write_Residue_Based_Data() ##




sub Write_Histogram{
 my($ofname,$Count,$RefCount,$comment) = @_;
 my($OF); my(@vallist); my(@vallist_ref); my($Nall);
 my($freq); my($freq_ref); my($odds); my($logodds);
 my($Cumu) = 0.0; 
 printf("#Write_Histogram()-->'%s'\n",$ofname);
 open(OF,">$ofname")||die "#ERROR:Can't write to ofname '$ofname'";
 printf(OF "#Write_Histogram()-->'%s'\n",$ofname);
 printf(OF "#COMMAND %s\n",$OPT{'COMMAND'}); 
 printf(OF "#DATE    %s\n",&Get_Date_String()); 
 foreach $x (@{$comment}){ printf(OF "#COMMENT %s\n",$x); }
 @vallist     = sort {$a <=> $b} keys(%{$Count});
 @vallist_ref = sort {$a <=> $b} keys(%{$RefCount});
 

 $Nall = 0;
 foreach $val (@vallist){$Nall += $Count->{$val};} 

 $Nall_ref = 0;
 foreach $val (@vallist_ref){$Nall_ref += $RefCount->{$val};} 
 
 printf(OF "#Nall $Nall Nall_ref $Nall_ref\n");


 printf(OF "#[x] [F(x)] [N(x)] [Cum(x)] [F(x)/Fref(x)] [log[F(x)/Fref(x)]] [Fref(x)]\n");  
 if ($Nall>0){
  foreach $val (@vallist){
   $freq     = $Count->{$val}/$Nall;
   $Cumu += $freq;
   printf(OF "%s %f %d %f",$val,$freq,$Count->{$val},$Cumu); 
   if ($Nall_ref>0){ 
    $freq_ref = $RefCount->{$val}/$Nall_ref;
    $odds = 0.0; $logodds = 0.0;
    if ($freq_ref>0){
     $odds = $freq/$freq_ref; 
      if ($odds>0) {$logodds = log($odds); }
     }
     printf(OF " %f %f %f",$odds,$logodds,$freq_ref);  
    } 
   printf(OF "\n"); 
  }
 }
 close(OF);
} ## end of Write_Histogram() ##


sub Count_Histogram{
 my($pdat,$Wbin,$Count,$property) = @_;
 my($res,$index);
 
 foreach $res (keys(%{$pdat})){
  $index = int($pdat->{$res}->{$property}/$Wbin)*$Wbin;
  $Count->{$index} += 1;
 }
} ## end of Count_Histogram() ##


sub Count_Histogram_Only_For_Binding_Residue{
 my($pdat,$Wbin,$Count,$property) = @_;
 my($res,$index);

 #printf("#sub Count_Histogram_Only_For_Binding_Residue($property)\n");
 foreach $res (keys(%{$pdat})){
  if ($pdat->{$res}->{'BIND'} == 1){
    if ($pdat->{$res}->{$property} ne ''){
      $index = int($pdat->{$res}->{$property}/$Wbin)*$Wbin;
      $Count->{$index} += 1;
    }
   }
 }
} ## end of Count_Histogram_Only_For_Binding_Residue() ##


sub Count_Histogram_Only_For_ACT_SITE_Residue{
 my($pdat,$Wbin,$Count,$property) = @_;
 my($res,$index);
 #printf("#sub Count_Histogram_Only_ACT_SITE_Residue('$property')\n");
 foreach $res (keys(%{$pdat})){
  if ($pdat->{$res}->{'ACT_SITE'} == 1){
   $index = int($pdat->{$res}->{$property}/$Wbin)*$Wbin;
   $Count->{$index} += 1;
   }
 }
} ## end of Count_Histogram_Only_For_ACT_SITE_Residue() ##


sub Count_Histogram_Only_For_MOD_RES_Residue{
 my($pdat,$Wbin,$Count,$property) = @_;
 my($res,$index);
 #printf("#sub Count_Histogram_Only_For_Binding_Residue($property)\n");
 foreach $res (keys(%{$pdat})){
  if ($pdat->{$res}->{'MOD_RES'} == 1){
   $index = int($pdat->{$res}->{$property}/$Wbin)*$Wbin;
   $Count->{$index} += 1;
   }
 }
} ## end of Count_Histogram_Only_For_MOD_RES_Residue() ##


sub Mark_Binding_Residue{
 my($pdat,$ldat,$lpat,$MatchLigList) = @_;

 print "#Mark_Binding_Residue()\n";
 my($Nbind) = 0;  my(%ExistLig) = (); 
 my(@liglist) = ();

 foreach $res (keys(%{$pdat})){
   #print "$res\n"; 
   @liglist = keys(%{$ldat->{$res}});
   $pdat->{$res}->{'BIND'} = 0;
   foreach $lig (@liglist){
    #print "lig $lig\n";
    if ($lig=~/$lpat/) {$pdat->{$res}->{'BIND'} = 1; $ExistLig{$lig} = 1;}
   }  
   if ($pdat->{$res}->{'BIND'} ==1) {++$Nbind;}
 }
 @{$MatchLigList} = keys(%ExistLig);   
 return($Nbind);
} ## end of Mark_Binding_Residue() ##


sub Mark_Binding_Residue_Not_Match_Pattern{
 my($pdat,$ldat,$nlpat,$MatchLigList) = @_;

 my($Nbind) = 0;  my(%ExistLig) = (); 
 my(@liglist) = ();

 foreach $res (keys(%{$pdat})){
   @liglist = keys(%{$ldat->{$res}});
   $pdat->{$res}->{'BIND'} = 0;
   foreach $lig (@liglist){
    if ($lig!~/$nlpat/) {$pdat->{$res}->{'BIND'} = 1; $ExistLig{$lig} = 1;}
   }  
   if ($pdat->{$res}->{'BIND'} ==1) {++$Nbind;}
 }
 @{$MatchLigList} = keys(%ExistLig);   
 return($Nbind);
} ## end of Mark_Binding_Residue() ##





sub Read_Residue_based_Pocketness_File{
 my($ifname,$dat) = @_;
 my($IF); 
 my($RNUM,$CHAIN,$RES,$shellAcc,$invRinacc,$pocketness,$Rinacc);
 open(IF,$ifname)||die "#ERROR:Can't open res-based pocket file '$ifname'";

#>> FILE EXAMPLE <<
# #COLUMN 1|RNUM      |Residue Number
# #COLUMN 2|CHAIN     |Chain Identifier
# #COLUMN 3|RES       |Three-letter residue name
# #COLUMN 4|shellAcc  |shell accessibility (%)
# #COLUMN 5|invRinacc |Average of inverse of Rinacc (1/A)
# #COLUMN 6|pocketness|[invRinacc] */(1/[RprobeS]) (%)
# #COLUMN 7|Rinvacc   |inverse of [invRinacc] (A)
#    1  A ALA  39.22 0.011712   2.19 85.380
#    2  A VAL  52.52 0.051019   9.54 19.601
#    3  A ASN  77.56 0.041348   7.73 24.185
#    4  A GLY  55.22 0.055561  10.39 17.998
#    5  A LYS  65.11 0.041982   7.85 23.820
#    6  A GLY  54.51 0.042088   7.87 23.760
#    7  A MET  44.75 0.013610   2.55 73.473
#    8  A ASN  52.22 0.030910   5.78 32.351
# :
# 1206  A ARG  85.19 0.040583   7.59 24.641
# 1207  A ASN  87.74 0.033620   6.29 29.744
# 1208  A ASP  90.74 0.021993   4.11 45.470
##COLUMN 1|RNUM        |Residue Number
##COLUMN 2|CHAIN       |Chain Identifier
##COLUMN 3|RES         |Three-letter residue name
##COLUMN 4|shellAcc    |shell accessibility (%)
##COLUMN 5|Rinacc      |averaged Rinaccess (A)
##COLUMN 6|rw_shellAcc |Rinacc-weighted shell accessibility (%)
##COLUMN 7|pocketness  |sum of 1/[Rpocket] /(1/[Rmin]*[vol of shell]) (%)
#   2  A THR  87.29  9.145  87.10   0.38
#   3  A PHE  88.18  9.246  88.06   0.20
#   4  A ASN  81.13  8.293  78.98   2.68
#   :
#1068  A MET  39.04  4.010  38.19   0.89
#1069  A HIS  51.79  5.056  48.15   3.54
#1070  A ALA  65.93  6.922  65.93   0.00
#1071  A GLN  63.68  6.500  61.90   1.89
#1072  A ILE  53.75  5.516  52.53   1.20
#1073  A LYS  88.37  9.112  86.78   1.60


 while (<IF>){
  if ($_!~/^#/){
   $_=~s/^\s+//;  
   ($RNUM,$CHAIN,$RES,$shellAcc,$Rinacc,$rw_shellAcc,$pocketness) = split(/\s+/,$_); 
   $index = $RNUM.' '.$CHAIN;
   #printf("RNUM '$RNUM' CHAIN '$CHAIN' INDEX '$index'\n"); 
   $dat->{$index}->{'RNUM'}  = $RNUM;
   $dat->{$index}->{'CHAIN'} = $CHAIN;
   $dat->{$index}->{'RES'} = $RES;
   $dat->{$index}->{'shellAcc'} = $shellAcc;
   $dat->{$index}->{'rw_shellAcc'} = $rw_shellAcc;
   $dat->{$index}->{'pocketness'} = $pocketness;
   $dat->{$index}->{'Rinacc'}     = $Rinacc;
  }
 } # while <IF> #
 close(IF);


} ## end of Read_Residue_based_Pocketness_File() ##

sub Read_Residue_based_Ligand_File{
 my($ifname,$dat) = @_;
 my($IF);  my($flag) = '';
 my($lig_head,$lig_name,$lig_chain,$lig_Nres,$lig_chem);
 my($RNUM,$CHAIN,$RES,$Nc_atm_self,$Nc_atm_tar,$Dc_min,$Plain_Rnum);
 my($index); 
 
 print "#Read_Residue_based_Ligand_File('$ifname')\n";
 open(IF,$ifname)||die "#ERROR:Can't open res-based ligand file '$ifname'";

 %{$dat} = ();

#>>FILE FORMAT EXAMPLE <<
# MODE       P
# CHAIN      A
# PROTEIN      1|pro|A|
#  PARTNER     2|NDP|A|1|C21_N7_O17_P3|
# # [RNUM] [CHAIN] [RES] [Nc_atm_self] [Nc_atm_tar] [Dc_min] [Plain_Rnum]
#     10  A VAL  3  2 3.592   10
#     11  A ALA  5  3 2.812   11
#     19  A ILE  4  3 3.152   19
#     55  A GLY  3  3 3.486   55
#     56  A ARG  6  8 2.718   56
#     57  A LYS  7  9 2.493   57
#  PARTNER     3|GW3|A|1|C15_N5|
# # [RNUM] [CHAIN] [RES] [Nc_atm_self] [Nc_atm_tar] [Dc_min] [Plain_Rnum]
#      9  A ILE  3  4 2.923    9
#     10  A VAL  4  3 3.527   10
#     11  A ALA  2  2 3.716   11
#    112  A ILE  4  2 2.995  112
#    118  A TYR  1  1 3.262  118
#    133  A THR  1  1 3.712  133
#  PARTNER     4|pro|B|192|C1003_N262_O292_S4|
# # [RNUM] [CHAIN] [RES] [Nc_atm_self] [Nc_atm_tar] [Dc_min] [Plain_Rnum]
#      2  A LEU  4  8 2.857    2
#      3  A LYS  6  5 2.920    3
#    125  A SER  4  3 2.639  125
#    192  A LYS  3  7 2.789  192
# //
 while (<IF>){
   chomp;
   if (($_!~/^#/)&&($_!~/^\//)){
    if (/^ PARTNER/){
    ($lig_head,$lig_name,$lig_chain,$lig_Nres,$lig_chem) = split(/\|/,$_); 
    $flag = 'P'; 
    } 
    elsif ($flag eq 'P'){
     $_=~s/^\s+//;
     ($RNUM,$CHAIN,$RES,$Nc_atm_self,$Nc_atm_tar,$Dc_min,$Plain_Rnum) = split(/\s+/,$_);
     $index = $RNUM.' '.$CHAIN;
     #print "index $index lig_name $ligname Nc_atm_self $Nc_atm_self\n";
     $dat->{$index}->{$lig_name} = $Nc_atm_self; 
    }
   } # if not ^# #

 } # while #
 close(IF); 
} ## end of Read_Residue_based_Ligand_File() ##



sub Read_Residue_based_LeeRich_ACC_File{
 my($ifname,$dat) = @_;
 my($IF);  my($flag) = '';
 my($RES,$CHAIN,$RNUM,$Natm,$ASA,$ACC,$RACC,$StdASA);
 my($index); 
 open(IF,$ifname)||die "#ERROR:Can't open res-based LeeRich file '$ifname'";
#>> FILE FORMAT EXAMPLE <<
# #Natm : Number of Atoms in the residue
# #ASA  : Solvent Accessible Surface of the residue [A^2]
# #ACC  : ASA normalized by that of full exposed atoms [%]
# #RACC : ASA normalized by that of Gly-X-Gly structures [%]
# #     RNUM Natm    ASA     ACC    RACC  StdASA
# ALA A  62     5   81.16    13.3    68.8   118.0
# MET A  63     8   90.81     9.0    44.3   205.1
# PHE A  64    11  109.34     8.1    50.5   216.7
# GLN A  65     9  114.83    10.6    63.2   181.8
# ILE A  66     8  106.83    10.6    57.9   184.4
# GLY A  67     4   27.05     5.7    30.3    89.3
# LYS A  68     9  156.61    14.1    75.8   206.7
# MET A  69     8   50.06     5.0    24.4   205.1
# ARG A  70    11  101.80     7.5    40.2   253.0
#
# THR A1004     7  169.50    20.2   111.7   151.8
# TYR A1005    12  177.28    12.2    77.1   229.8
# ASN A1006     8   95.52    10.1    61.7   154.9
# ALA A1007     5   87.21    14.4    73.9   118.0
# ASP A1008     8  119.69    12.9    76.8   155.8
# ALA A1009     5   46.86     7.7    39.7   118.0
# 01234567890123456789012345678901234567890123456
#           1         2         3         4 
##COLUMN 1|RNUM    | Residue number
##COLUMN 2|ChainID | Chain Identifier
##COLUMN 3|Residue | Three-letter residue name
##COLUMN 4|Natm    | Number of Atoms in the residue
##COLUMN 5|ASA     | Solvent Accessible Surface of the residue [A^2]
##COLUMN 6|ACC     | ASA normalized by that of full exposed atoms [%]
##COLUMN 7|RACC    | ASA normalized by that of Gly-X-Gly structures [%]
##COLUMN 8|StdASA  | Solvent Accessible Surfarce of residue X in Gly-X-Gly [A^2]
##[RNUM][RES][Natm][ASA]   [ACC%]  [RACC%] [StdASA(AA)]
#  10  A TRP   14   94.13     5.5    36.1   260.6
#  11  A LYS    9  106.00     9.5    51.3   206.7
#  12  A GLN    9  123.10    11.4    67.7   181.8
#  13  A ALA    5   16.27     2.7    13.8   118.0
#  14  A GLU    9  155.61    14.7    88.7   175.5
#  15  A ASP    8   52.06     5.6    33.4   155.8
#  16  A ILE    8    5.06     0.5     2.7   184.4
#01234567890123456789012345678901234567890123456
#          1         2         3         4 


 while (<IF>){
  chomp;
  if ($_!~/^#/){
   $RNUM   = substr($_,0,5);  $RNUM =~s/\s+//g;
   $CHAIN  = substr($_,6,1);
   $RES    = substr($_,8,3);
   $Natm   = substr($_,12,4); $Natm =~s/\s+//g;
   $ASA    = substr($_,16,8); $ASA  =~s/\s+//g;
   $ACC    = substr($_,24,8); $ACC  =~s/\s+//g;
   $RACC   = substr($_,32,8); $RACC =~s/\s+//g;
   $StdASA = substr($_,40,8); $StdASA =~s/\s+//g;
 
 # ($RES,$CHAIN,$RNUM,$Natm,$ASA,$ACC,$RACC,$StdASA) = split(/\s+/,$_);   
   $index = $RNUM.' '.$CHAIN;
   if ($RACC<0){
    printf("$_\n"); 
   }
   $dat->{$index}->{'RACC'} = $RACC;
   $dat->{$index}->{'ACC'}  = $ACC;
   $dat->{$index}->{'ASA'}  = $ASA;
  } 
}
 close(IF);
} ## end of Read_Residue_based_LeeRich_ACC_File() ##



sub Read_PDBINF_File{
 my($ifname,$dat) = @_;
 my($IF);  my($flag) = '';

#>> FILE FORMAT EXAMPLE <<
# ENTRY          1a0cA
# LENGTH         437
# MOLNAME        XYLOSE ISOMERASE
# SWS_ID         XYLA_THETU
# SWS_DE         Xylose isomerase (EC 5.3.1.5).
# SWS_LENGTH     439
# SWS_HOMOLOGY   100.00|437|0.0
# SWS_CC         -!- CATALYTIC ACTIVITY: D-xylose = D-xylulose.
# SWS_CC         -!- COFACTOR: Binds 2 cobalt ions per subunit.
# SWS_CC         -!- SUBUNIT: Homotetramer.
# SWS_CC         -!- SUBCELLULAR LOCATION: Cytoplasm.
# SWS_CC         -!- SIMILARITY: Belongs to the xylose isomerase family.
# SWS_KW         3D-structure; Carbohydrate metabolism; Cobalt; Direct protein sequencing; Isomerase; Metal-binding; Pentose shunt; Xylose metabolism.
# SCOP_TAXONOMY  c.1.15.3
# SCOP_DOMAIN    c.1.15.3|A:- -> -
# FAMILY_ID      F100-208   1
# FAMILY_ID      F95-52     1
# FAMILY_ID      F40-41     3
# FAMILY_ID      FE4-39     78
# ALIGN_INFO     PDB 1(1)-437(437)/437 |SWS 2-438/439|Ncomp 437|SqID 100.0
# SWS_FT         ACT_SITE   100 H (  101 H)   100 H (  101 H)
# SWS_FT         ACT_SITE   103 D (  104 D)   103 D (  104 D) By similarity.
# SWS_FT         METAL      231 E (  232 E)   231 E (  232 E) Cobalt 1.
# SWS_FT         METAL      267 E (  268 E)   267 E (  268 E) Cobalt 1.
# SWS_FT         METAL      267 E (  268 E)   267 E (  268 E) Cobalt 2.
# SWS_FT         METAL      270 H (  271 H)   270 H (  271 H) Cobalt 2.
# SWS_FT         METAL      295 D (  296 D)   295 D (  296 D) Cobalt 1.
# SWS_FT         METAL      306 D (  307 D)   306 D (  307 D) Cobalt 2.
# SWS_FT         METAL      308 D (  309 D)   308 D (  309 D) Cobalt 2.
# SWS_FT         METAL      338 D (  339 D)   338 D (  339 D) Cobalt 1.
# SWS_FT         MUTAGEN    100 H (  101 H)   100 H (  101 H) H->F: Abolishes activity.
# //

 my($entry,$CHAIN,$head1,$head2,$RNUM,$aa,$index);
 open(IF,$ifname)||die "#ERROR:Can't open pdbinf file '$ifname'";

 while (<IF>){
  chomp;
 
# ENTRY          1a0cA
  if ($_=~/^ENTRY     /){
   ($head1,$entry) = split(/\s+/,$_);
    $CHAIN = substr($entry,4,1);
  # print "entry '$entry' chain '$CHAIN'\n";
  }
# SWS_FT         ACT_SITE   100 H (  101 H)   100 H (  101 H)
# SWS_FT         ACT_SITE   103 D (  104 D)   103 D (  104 D) By similarity.
  if ($_=~/^SWS\_FT         ACT_SITE/){
   ($head1,$head2,$RNUM,$aa) = split(/\s+/,$_); 
   $index = $RNUM.' '.$CHAIN;
   #printf("##ACT_SITE head1 $head1 head2 $head2 RNUM $RNUM aa $aa index '$index'\n");  
   $dat->{$index}->{'ACT_SITE'} = 1;
  } 
  if ($_=~/^SWS\_FT         MOD_RES/){
   ($head1,$head2,$RNUM,$aa) = split(/\s+/,$_); 
   $index = $RNUM.' '.$CHAIN;
   #printf("##ACT_SITE head1 $head1 head2 $head2 RNUM $RNUM aa $aa index '$index'\n");  
   $dat->{$index}->{'MOD_RES'} = 1;
  } 
}
 close(IF);
} ## end of Read_PDBINF_File() ##


sub Read_PsiBlast_Profile_File{
 my($ifname,$dat) = @_;

 printf("#Read_PsiBlast_Profile_File(%s)\n",$ifname);
#Last position-specific scoring matrix computed, weighted observed percentages rounded down, information per position, and relative weight of gapless real matches to pseudocounts           A  R  N  D  C  Q  E  G  H  I  L  K  M  F  P  S  T  W  Y  V   A   R   N   D   C   Q   E   G   H   I   L   K   M   F   P   S   T   W   Y   V

#    1 Y   -3 -3 -3 -4 -3 -3 -3 -4  0 -1 -1 -3 -1  6 -4 -3 -2  1  6 -2    0   0   0   0   0   0   0   0   0   0   0   0   0  56   0   0   0   0  44   0  0.96 0.15
#    2 T   -1 -2 -1 -2 -2 -2 -2 -2 -3 -2 -2 -2 -2 -3 -2  3  6 -4 -3 -1    0   0   0   0   0   0   0   0   0   0   0   0   0   0   0  22  78   0   0   0  0.86 0.36
#    3 P    1 -3 -2 -3 -3 -2 -2  1 -2 -3 -3 -2 -3 -2  6  2 -1 -3  3 -1   10   0   0   0   0   0   0  11   0   0   0   0   0   0  41  18   0   0  13   7  0.78 0.40
#    4 I    2 -3 -4 -4 -2 -3 -3 -3 -4  4  1 -3  0 -2 -3 -2 -2 -4 -3  3   28   0   0   0   0   0   0   0   0  34  14   0   0   0   0   0   0   0   0  23  0.50 0.41
#    5 D   -2 -2  4  4 -4 -1  3 -3 -2  0 -3 -2 -3 -4 -3  1  1 -5 -3 -2    0   0  23  30   0   0  19   0   0  11   0   0   0   0   0   9   9   0   0   0  0.57 0.45
#
 my($IF,@AAarray,@field,$num,$i,$aa,%AA,%prof,%freq,%info,%weight,$entropy,$f,$Nnonzero);
 my($entmax) = -log(1.0/20.0)/log(2.0); 
 #printf("#entmax $entmax\n");
 if (-e $ifname){ open(IF,$ifname);}
  else
   { print "#WARNING:Can't open profile file '$ifname'\n";
     return(0);
    }
 @AAarray = ('A','R','N','D','C','Q','E','G','H','I','L','K','M','F','P','S','T','W','Y','V');
 
 while (<IF>){
   chomp;
   if ((length($_)>50)&&($_!~/^Last position/)){
    $_=~s/^\s+//;
    @field = split(/\s+/,$_);
    $num     = $field[0];
    $AA{$num} = $field[1];
    for ($i=0;$i<20;++$i) {$prof{$num}->{$AAarray[$i]} = $field[$i+2];}
    for ($i=0;$i<20;++$i) {$freq{$num}->{$AAarray[$i]} = $field[$i+22];}
    $info{$num}   = $field[42];
    $weight{$num} = $field[43];
    } 
 } # while #

 close(IF);


 ### Calculate Entropy ##

 $log2 = log(2.0); 
 @indexlist = sort {$a <=> $b}keys(%{$dat});

 foreach $index (@indexlist){
  $num = $dat->{$index}->{'SEQNUM'};
  $aa  = $AA{$num};
 # printf("index %s num %s aa %s\n",$index,$num,$aa);
  $dat->{$index}->{'FREQ'} = $freq{$num}->{$aa};
  $dat->{$index}->{'PROF'} = $prof{$num}->{$aa};
  $dat->{$index}->{'INFO'} = $info{$num};
  $entropy = 0.0; 
  $Nnonzero = 0;
  $maxfreq = 0.0;
  
  foreach $aa (@AAarray){
   $f = 0.01*$freq{$num}->{$aa};
   #print "$aa $f\n";
   if ($f>0.0) { $entropy -= $f*log($f)/$log2; ++$Nnonzero;}
    if ($f>$maxfreq){ $maxfreq = $f;}
  } # $aa #

  if ($Nnonzero==0) {
    $dat->{$index}->{'ENTROPY'} = '';
    $dat->{$index}->{'MAXFREQ'} = '';
   }
  else{
  $dat->{$index}->{'ENTROPY'}  = $entropy;
  $dat->{$index}->{'MAXFREQ'} = $maxfreq;
  }
  #if ($entropy>$entmax){
  # printf("WOOPS!! $ifname $index $num entro $entropy entmax $entmax\n");
  # foreach $aa (@AAarray){
  #  printf("%s %s\n",$aa,$freq{$num}->{$aa});
  # }
  #} 

  #printf("%s RES %s INFO %f ENTRO %f MAXFREQ %f\n",$index,
  #$dat->{$index}->{'RES'},$dat->{$index}->{'INFO'},$dat->{$index}->{'ENTROPY'},$dat->{$index}->{'MAXFREQ'});

 } # $index #
 

 return(1);
} ## end of Read_PsiBlast_Profile_File{



sub Read_Vertical_PDB_Num_Sequence_File{
 my($ifname,$dat) = @_;

#>> FILE FORMAT EXAMPLE <<
# >1kxlAA Exp N Res - Naa  187 Mch 100 Unk   0 Mut - Tax - Nreg 0
# #[num] [AA] [RnumPDB] [ChainID] [TriAA]
# 1    K    5  A LYS
# 2    M    6  A MET
# 3    A    7  A ALA
# 4    R    8  A ARG
# 5    K    9  A LYS
# 6    D   10  A ASP
# 7    P   11  A PRO
# 8    T   12  A THR
# 9    I   13  A ILE
# :
# 187  I  191  A ILE
# //

 my($IF,$num,$aa,$pdbnum,$chain,$triaa,$index);
 printf("#Read_Vertical_PDB_Num_Sequence_File('$ifname')\n");
 if (!-e $ifname) {
  print "WARNING:Can't open VerSeqfile '$ifname'";
  return(0); 
 }
 open(IF,$ifname) || die "#ERROR:Can't open VerSeqfile '$ifname'";
 while (<IF>){
  chomp;
  if (($_=~/^[0-9]/)&&(length($_)>5)){
   ($num,$aa,$pdbnum,$chain,$triaa) = split(/\s+/,$_);
   $index = $pdbnum.' '.$chain;
   $dat->{$index}->{'SEQNUM'} = $num;
   $dat->{$index}->{'aa_sym'} = $aa;
  # printf("index '$index' num '$num'\n");
  } 
 } # while #
 close(IF);
 return(1);
} ## end of Read_Vertical_PDB_Num_Sequence_File() ##


 

sub Read_Options{
 # $_[0] : ref of \@ARGV
 # $_[1] : ref of \%OPT
                                                                                                      
 # This script is reading following style options :
 #   psiscan.pl org41list -lib 95pdb01Mar4Mx -tail -I -C
 # In principle, the format is the style like  "[-option] [value]"
 # If [value] is omitted, [option] is set to '1'.
 
 my($x); my($x1); my($i);
                                                                                                      
 $_[1]->{'COMMAND'} = "$0 ";
 foreach $x (@ARGV) { $_[1]->{'COMMAND'} .= "$x ";}
                                                                                                      
 $i = 0;
 while ($i<scalar(@ARGV))
 {
  $x  = $_[0]->[$i];
  $x1 = $_[0]->[$i+1];
  if ($x =~/^\-/)
   { $x =~s/^\-//;
     if ((length($x1)>0) && ($x1 !~/\-/)) { $_[1]->{$x} = $x1; ++$i; }
     else { $_[1]->{$x} = '';}
   }
  ++$i;
 }
} ## end of Read_Options() ##




sub Read_List_File{
 my($fname,$list) = @_;
 my(@D);
                                                                                                      
 ## GENERAL FUNCTION FOR READING LIST FILE
 ## Read only 1st field.
 ## [FILE_EXAMPLE]
 ## 1dlwA  a.1.1.1
 ## 1a6m-  a.1.1.2
 ## 1eca-  a.1.1.2
 ## 1lh1-  a.1.1.2
 ## 1ash-  a.1.1.2
                                                                                                      
open(F,$fname) || die "#ERROR:Can't find listfile \"$fname\"";
 @{$list} = ();
 
 while (<F>){
  if ($_!~/^#/){
   chop;
   @D = split(/\s+/,$_);
   push(@{$list},$D[0]);
  }
 }
 close(F);
} ## end of Read_List_File()
                                                                                                      
                                                                                                      
sub Get_Date_String{
 my(@Month) = ('Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec');
 my(@date) = localtime(time());
 my($year)  = $date[5]+1900;
 my($month) = $Month[$date[4]];
 my($day)   = $date[3];
 return("$month $day $year, $date[2]:$date[1]:$date[0]");

} ## end of Get_Date_String() ##

